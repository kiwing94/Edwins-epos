// Full update with object list panel, hitbox UI, and visual outline
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Atechne Live GUI Runtime</title>
  <style>
    body { margin: 0; display: flex; font-family: sans-serif; background: #111; color: #eee; }
    canvas { background: #222; flex: 1; display: block; cursor: grab; }
    #editor {
      width: 300px;
      background: #1a1a1a;
      padding: 10px;
      overflow-y: auto;
      height: 100vh;
    }
    input, textarea, button, select {
      width: 100%; margin-bottom: 10px; padding: 5px; background: #333; color: #fff; border: none;
    }
    label { font-size: 12px; color: #aaa; display: block; margin-top: 10px; }
    .object-panel { border: 1px solid #333; padding: 10px; margin-bottom: 10px; }
    #preview {
      width: 100%; height: 100px; background: #000; display: flex; align-items: center; justify-content: center; margin-bottom: 10px;
    }
    #preview img { max-height: 80px; max-width: 80px; }
    #objectSelector {
      width: 100%; margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <div style="position: absolute; top: 0; left: 0; width: 100%; background: #000; color: #fff; padding: 5px; font-size: 14px; text-align: center; z-index: 1000; border-bottom: 1px solid #333;">
    ðŸŽ® Atechne RPG Engine - Made with Love by Edwin Jonathan Gustavsson
  </div>
  <canvas id="game" width="800" height="600"></canvas>
  <div id="mobHUD" style="position: absolute; top: 40px; right: 10px; width: 200px; background: rgba(50,0,0,0.7); color: #fff; padding: 10px; font-size: 12px; border: 1px solid #400; display: none;">
    <div id="mobName">Mob: </div>
    <div id="mobHPText">HP: </div>
    <div style="margin-top: 5px; height: 5px; background: #444;">
      <div id="mobHpBar" style="height: 5px; background: darkred; width: 100%;"></div>
    </div>
    <div id="mobStatus" style="margin-top: 5px; font-size: 11px; color: #faa;"></div>
  </div>
  <div id="hud" style="position: absolute; top: 40px; left: 10px; width: 220px; background: rgba(0,0,0,0.7); color: #fff; padding: 10px; font-size: 12px; border: 1px solid #444;">
    <div id="hudGold">ðŸ’° Gold: 0</div>
    <div id="hudName">Name: </div>
    <div id="hudClass">Class: </div>
    
        Physical: <span id="hudPHY">0</span><br>
        Range: <span id="hudRNG">0</span><br>
        HP: <span id="hudHP">100</span><br>
        MP: <span id="hudMP">50</span><br>
        ATK: <span id="hudATK">0</span><br>
        DEF: <span id="hudDEF">0</span><br>
        Bonus: <span id="hudBONUS">0</span>
      </div>
    </div>
    <div style="margin-top: 5px; height: 5px; background: #444;">
      <div id="hpBar" style="height: 5px; background: red; width: 100%;"></div>
    </div>
    <div style="margin-top: 2px; height: 5px; background: #444;">
      <div id="mpBar" style="height: 5px; background: blue; width: 50%;"></div>
    </div>
  </div>
  <div id="editor">
    <h3>ðŸ›  Atechne Live Editor</h3>
    <div id="preview"><span style="color:#555">No sprite selected</span></div>
    <label>Grid Snap</label>
    <input type="number" id="gridSize" value="20" min="1" />
    <label>ðŸ“‹ Objects</label>
    <select id="objectSelector" onchange="selectObject(this.value)"></select>
    <button onclick="addObject()">Add Object</button>
    <button onclick="exportATE()">Export .ate</button>
    <pre id="output"></pre>
    <div id="objectList"></div>
  </div>

  
    const levelUpSound = new Audio("https://cdn.pixabay.com/download/audio/2021/08/08/audio_f58e3f7b5c.mp3?filename=level-up-141079.mp3");
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const output = document.getElementById("output");
    const preview = document.getElementById("preview");
    const gridSizeInput = document.getElementById("gridSize");
    const objectSelector = document.getElementById("objectSelector");

    const objects = [];
const keys = {};
let gravity = 0.5;
let groundY = 560;
    let selectedObjectIndex = null;
    let dragging = null;
    let offsetX = 0;
    let offsetY = 0;

    canvas.addEventListener("mousedown", e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      for (let i = 0; i < objects.length; i++) {
        const obj = objects[i];
        if (mx >= obj.x && mx <= obj.x + obj.width && my >= obj.y && my <= obj.y + obj.height) {
          dragging = obj;
          selectedObjectIndex = i;
          objectSelector.value = i;
          updatePreview(obj.sprite);
          offsetX = mx - obj.x;
          offsetY = my - obj.y;
          canvas.style.cursor = "grabbing";
          break;
        }
      }
    });

    canvas.addEventListener("mousemove", e => {
      if (dragging) {
        const rect = canvas.getBoundingClientRect();
        const gx = e.clientX - rect.left - offsetX;
        const gy = e.clientY - rect.top - offsetY;
        const grid = parseInt(gridSizeInput.value || 1);
        dragging.x = Math.round(gx / grid) * grid;
        dragging.y = Math.round(gy / grid) * grid;
      }
    });

    canvas.addEventListener("mouseup", () => {
      dragging = null;
      canvas.style.cursor = "grab";
    });

    window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
    window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
    });

    function updatePreview(sprite) {
      preview.innerHTML = sprite ? `<img src="${sprite}" alt="sprite" />` : '<span style="color:#555">No sprite selected</span>';
    }

    function selectObject(index) {
      selectedObjectIndex = parseInt(index);
      const obj = objects[selectedObjectIndex];
      if (obj) updatePreview(obj.sprite);
    }

    function addObject() {
      const obj = {
      stats: { physical: 5, range: 5 },
      level: 1,
      exp: 0,
      maxExp: 100,
        type: "mob",
        variant: Math.floor(Math.random() * 5),
        class: "Adventurer",
        hp: 100,
        speed: 1,
        x: 100,
        y: 100 + objects.length * 80,
        width: 40,
        height: 40,
        script: "obj.x += obj.speed;",
        sprite: "",
        animation: [],
        flip: "none",
        sound: "",
        animSpeed: 200,
        weapon: null
      };

      const weaponTypes = ["Sword", "Dagger", "Staff", "Bow"];
      const rarities = ["Common", "Rare", "Epic", "Legendary"];

      function generateWeapon(type = "Sword") {
        const rarity = rarities[Math.floor(Math.random() * rarities.length)];
        const baseAtk = Math.floor(Math.random() * 10 + 5);
        const atkMultiplier = { Common: 1, Rare: 1.5, Epic: 2.5, Legendary: 4 }[rarity];
        const attack = Math.floor(baseAtk * atkMultiplier);
        const name = `${rarity} ${type} of Power`;
        return { type, name, attack, rarity };
      }

      const index = objects.length;
      objects.push(obj);

      const opt = document.createElement("option");
      opt.value = index;
      opt.textContent = `${obj.name} (${obj.class})`;
      objectSelector.appendChild(opt);

      const wrapper = document.createElement("div");
      wrapper.className = "object-panel";

      const classLabel = document.createElement("label");
      classLabel.textContent = "Class";
      const classSelect = document.createElement("select");
      ["Adventurer", "Bandit", "Sorcerer", "Goblin"].forEach(c => {
        const option = document.createElement("option");
        option.value = c;
        option.textContent = c;
        if (c === obj.class) option.selected = true;
        classSelect.appendChild(option);
      });
      classSelect.onchange = () => {
        obj.class = classSelect.value;
        if (obj.class === "Bandit") obj.stats.physical += 3;
        if (obj.class === "Sorcerer") obj.stats.range += 3;
        opt.textContent = `${obj.name} (${obj.class})`;
      };

      const weaponLabel = document.createElement("label");
      weaponLabel.textContent = "Weapon";
      const physicalInput = document.createElement("input");
      physicalInput.type = "number";
      physicalInput.value = obj.stats.physical;
      physicalInput.onchange = () => obj.stats.physical = parseInt(physicalInput.value);
      const rangeInput = document.createElement("input");
      rangeInput.type = "number";
      rangeInput.value = obj.stats.range;
      rangeInput.onchange = () => obj.stats.range = parseInt(rangeInput.value);
      const statLabel = document.createElement("label");
      statLabel.textContent = "Stats";
      const statBlock = document.createElement("div");
      statBlock.innerHTML = "Physical:<br>";
      statBlock.appendChild(physicalInput);
      statBlock.innerHTML += "Range:<br>";
      statBlock.appendChild(rangeInput);
      weaponInfo.style.fontSize = "12px";
      weaponInfo.style.color = "#ccc";
      weaponInfo.textContent = "(none)";

      const generateBtn = document.createElement("button");
      generateBtn.textContent = "Generate Weapon";
      generateBtn.onclick = () => {
        const type = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
        obj.weapon = generateWeapon(type);
        weaponInfo.textContent = `${obj.weapon.name} | ATK: ${obj.weapon.attack}`;
      };

      wrapper.appendChild(classLabel);
      wrapper.appendChild(classSelect);
      wrapper.appendChild(weaponLabel);
      wrapper.appendChild(weaponInfo);
      wrapper.appendChild(generateBtn);
      wrapper.appendChild(statLabel);
      wrapper.appendChild(statBlock);

      const skillLabel = document.createElement("label");
      skillLabel.textContent = "Skills";
      const skillSelect = document.createElement("select");
      skillSelect.multiple = true;
      skillSelect.size = 3;
      ["defensive", "utility", "speed"].forEach(skill => {
        const option = document.createElement("option");
        option.value = skill;
        option.textContent = skill.charAt(0).toUpperCase() + skill.slice(1);
        if (obj.skills && obj.skills.includes(skill)) option.selected = true;
        skillSelect.appendChild(option);
      });
      skillSelect.onchange = () => {
        obj.skills = Array.from(skillSelect.selectedOptions).map(opt => opt.value);
      };
      wrapper.appendChild(skillLabel);
      wrapper.appendChild(skillSelect);

      document.getElementById("objectList").appendChild(wrapper);
      const index = objects.length;
      objects.push(obj);

      const opt = document.createElement("option");
      opt.value = index;
      opt.textContent = `${obj.name} (${obj.class})`;
      objectSelector.appendChild(opt);

      const wrapper = document.createElement("div");
      wrapper.className = "object-panel";
      const classLabel = document.createElement("label");
      classLabel.textContent = "Class";
      const classSelect = document.createElement("select");
      ["Adventurer", "Bandit", "Sorcerer", "Goblin"].forEach(c => {
        const option = document.createElement("option");
        option.value = c;
        option.textContent = c;
        if (c === obj.class) option.selected = true;
        classSelect.appendChild(option);
      });
      classSelect.onchange = () => {
        obj.class = classSelect.value;
        opt.textContent = `${obj.name} (${obj.class})`;
      };
      wrapper.appendChild(classLabel);
      wrapper.appendChild(classSelect);
      document.getElementById("objectList").appendChild(wrapper);
      objects.push(obj);
      const opt = document.createElement("option");
      opt.value = index;
      opt.textContent = `${obj.name} (${obj.class})`;
      objectSelector.appendChild(opt);
    }

    function exportATE() {
      let ate = "";
      for (const obj of objects) {
        ate += `Object ${obj.name}
  class ${obj.class}
  hp ${obj.hp}\n  speed ${obj.speed}\n  width ${obj.width}\n  height ${obj.height}\n`;
        if (obj.sprite) ate += `  sprite ${obj.sprite}\n`;
        if (obj.animation && obj.animation.length > 0) {
          ate += `  animation ${obj.animation.join(', ')}\n`;
        }
        if (obj.animSpeed) ate += `  animSpeed ${obj.animSpeed}\n`;
        if (obj.flip && obj.flip !== 'none') ate += `  flip ${obj.flip}\n`;
        if (obj.weapon) ate += `  weapon ${obj.weapon.name} atk ${obj.weapon.attack} rarity ${obj.weapon.rarity}
`;
        if (obj.armor) ate += `  armor ${obj.armor.name} def ${obj.armor.defense} rarity ${obj.armor.rarity}
`;
        if (obj.accessory) ate += `  accessory ${obj.accessory.name} bonus ${obj.accessory.bonus} rarity ${obj.accessory.rarity}
`;
        if (obj.sound) ate += `  sound ${obj.sound}
`;
        ate += `  on update\n`;
        for (const line of obj.script.split("\n")) {
          ate += `    ${line}\n`;
        }
      }
      output.textContent = ate;
    }

    function draw() {
      const hudName = document.getElementById("hudName");
      const hudClass = document.getElementById("hudClass");
      const hudHP = document.getElementById("hudHP");
      const hudMP = document.getElementById("hudMP");
      const hudATK = document.getElementById("hudATK");
      const hudDEF = document.getElementById("hudDEF");
      const hudBONUS = document.getElementById("hudBONUS");
      if (!document.getElementById("hudLVL")) {
        const lvlSpan = document.createElement("div");
        lvlSpan.id = "hudLVL";
        lvlSpan.textContent = "Level: 1";
        document.getElementById("hudStats").prepend(lvlSpan);
      }
      const hudLVL = document.getElementById("hudLVL");
      const hpBar = document.getElementById("hpBar");
      const mpBar = document.getElementById("mpBar");
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let i = 0; i < objects.length; i++) {
        const obj = objects[i];
        try {
          const f = new Function("obj", obj.script);
          f(obj);

          if (i === selectedObjectIndex) {
            // Movement physics only for selected (player)
            if (!obj.vx) obj.vx = 0;
            if (!obj.vy) obj.vy = 0;
            if (keys["arrowleft"] || keys["a"]) obj.vx = -obj.speed;
            else if (keys["arrowright"] || keys["d"]) obj.vx = obj.speed;
            else obj.vx = 0;

            if ((keys["arrowup"] || keys["w"]) && obj.y >= groundY - obj.height) {
              obj.vy = -10; // jump
            }

            obj.vy += gravity;
            obj.x += obj.vx;
            obj.y += obj.vy;

            if (obj.y >= groundY - obj.height) {
              obj.y = groundY - obj.height;
              obj.vy = 0;
            }
          }
        } catch (e) {
          console.warn("Script error:", e);
        }
        if (i === selectedObjectIndex) {
          ctx.strokeStyle = "#ff0";
          ctx.lineWidth = 2;
          ctx.strokeRect(obj.x - 2, obj.y - 2, obj.width + 4, obj.height + 4);
        }
        ctx.fillStyle = obj.type === "mob" ? "rgba(255,0,0,0.3)" : "rgba(0,255,0,0.3)";
        ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
        ctx.fillStyle = "white";
        ctx.fillText(`${obj.name}${obj.variant === 4 ? ' (Boss)' : ''}`, obj.x + 5, obj.y + obj.height + 15);
        if (obj.showCrit) {
          ctx.fillStyle = "yellow";
          ctx.font = "bold 14px sans-serif";
          ctx.fillText("CRIT!", obj.x + obj.width / 2 - 10, obj.y - 15);
          obj.critTimer--;
          if (obj.critTimer <= 0) obj.showCrit = false;
        }
        if (obj.type === "mob") {
          const maxHp = 100;
          const hp = Math.max(0, obj.hp || maxHp);
          const barWidth = obj.width;
          const barHeight = 5;
          const hpRatio = hp / maxHp;
          ctx.fillStyle = "black";
          ctx.fillRect(obj.x, obj.y - 10, barWidth, barHeight);
          ctx.fillStyle = "lime";
          ctx.fillRect(obj.x, obj.y - 10, barWidth * hpRatio, barHeight);
        }
      }
      // Handle player attacking mobs
      if (keys[" "] && selectedObjectIndex !== null) {
        const player = objects[selectedObjectIndex];
        let baseAtk = player.weapon ? player.weapon.attack : 5;
        let critChance = 0.1;
        if (player.class === "Bandit") critChance = 0.3;
        if (player.class === "Sorcerer") critChance = 0.2;
        if (player.class === "Adventurer") critChance = 0.1;
        if (player.class === \"Goblin\") critChance = 0.05;
        let critMultiplier = 2;
        if (player.class === \"Goblin\") critMultiplier = 3;
        const isCrit = Math.random() < critChance;
        const atk = isCrit ? Math.floor(baseAtk * critMultiplier) : baseAtk;
        for (const mob of objects) {
          if (mob !== player && mob.type === "mob") {
            const collides =
              player.x < mob.x + mob.width &&
              player.x + player.width > mob.x &&
              player.y < mob.y + mob.height &&
              player.y + player.height > mob.y;
            if (collides) {
              let defense = mob.armor ? mob.armor.defense : 0;
              if (mob.stats && mob.stats.physical) defense += Math.floor(mob.stats.physical / 4);
              if (mob.skills && mob.skills.includes("defensive")) defense += 3;
              const reducedDmg = Math.max(1, atk - defense);
              mob.hp = (mob.hp || 100) - reducedDmg;
              if (isCrit) {
                mob.showCrit = true;
                mob.critTimer = 30;
              }
              if (isCrit) console.log("Critical Hit!");
              console.log(`Dealt ${atk}${isCrit ? ' (crit)' : ''} â†’ ${reducedDmg} after armor`);
              if (mob.hp <= 0) {
                mob.dead = true;
                player.exp = (player.exp || 0) + 25;
                while (player.exp >= player.maxExp && player.level < 30) {
                  player.exp -= player.maxExp;
                  player.level++;
                  player.maxExp = Math.floor(player.maxExp * 1.5);
                  player.hp = 100 + player.level * 5;
                  console.log(`Level up! Level ${player.level}`);
                  const msg = document.createElement("div");
                  msg.textContent = "ðŸŽ‰ You have reached a new level, congrats Adventurer!";
                  msg.style.cssText = "position:absolute;top:50px;left:50%;transform:translateX(-50%);background:gold;color:black;padding:10px 20px;border-radius:10px;font-weight:bold;z-index:1001;box-shadow:0 0 10px #000;";
                  document.body.appendChild(msg);
                  setTimeout(() => msg.remove(), 3000);
                  levelUpSound.play();
                }
              }
            }
          }
        }
      }

      // Drop loot when mob dies
      for (let i = objects.length - 1; i >= 0; i--) {
        const mob = objects[i];
        if (mob.dead) {
          if (Math.random() < 0.7) {
            const loot = {
              name: "Coin",
              type: "loot",
              x: mob.x,
              y: mob.y,
              width: 10,
              height: 10,
              value: Math.floor(Math.random() * 10 + 5),
              sprite: "",
              collected: false
            };
            objects.push(loot);
          }
          objects.splice(i, 1);
        }
      }

      // Collect loot if player overlaps
      if (selectedObjectIndex !== null) {
        const player = objects[selectedObjectIndex];
        for (const obj of objects) {
          if (obj.type === "loot" && !obj.collected) {
            const overlap =
              player.x < obj.x + obj.width &&
              player.x + player.width > obj.x &&
              player.y < obj.y + obj.height &&
              player.y + player.height > obj.y;
            if (overlap) {
              obj.collected = true;
              console.log(`Collected ${obj.name}: +${obj.value} gold`);
              obj.name = `+${obj.value}`;
              player.gold = (player.gold || 0) + obj.value;
              document.getElementById("hudGold").textContent = `ðŸ’° Gold: ${player.gold}`;
            }
          }
        }
      }

      if (selectedObjectIndex !== null) {
        const obj = objects[selectedObjectIndex];
        hudName.textContent = `Name: ${obj.name}`;
        hudClass.textContent = `Class: ${obj.class}`;
        hudHP.textContent = obj.hp;
        hudMP.textContent = obj.mp || 50;
        hudATK.textContent = obj.weapon ? obj.weapon.attack : 0;
        hudDEF.textContent = obj.armor ? obj.armor.defense : 0;
        hudBONUS.textContent = obj.accessory ? obj.accessory.bonus : 0;
        
        if (!obj.stats) obj.stats = { physical: 5, range: 5 };
        if (!obj.skills) obj.skills = [];
        document.getElementById("hudPHY").textContent = obj.stats.physical;
        document.getElementById("hudRNG").textContent = obj.stats.range;
        if (!document.getElementById("expBar")) {
          const bar = document.createElement("div");
          bar.id = "expBarContainer";
          bar.style.cssText = "margin-top:2px;height:5px;background:#444;";
          const inner = document.createElement("div");
          inner.id = "expBar";
          inner.style.cssText = "height:5px;background:orange;width:0%;";
          bar.appendChild(inner);
          document.getElementById("hud").appendChild(bar);
        }
        const expBar = document.getElementById("expBar");
        const expRatio = Math.min(1, (obj.exp || 0) / (obj.maxExp || 100));
        expBar.style.width = `${expRatio * 100}%`;
        if (!document.getElementById("expText")) {
          const expText = document.createElement("div");
          expText.id = "expText";
          expText.style.fontSize = "10px";
          expText.style.color = "#ccc";
          document.getElementById("hud").appendChild(expText);
        }
        const expText = document.getElementById("expText");
        expText.textContent = `EXP: ${obj.exp} / ${obj.maxExp}`;
        hpBar.style.width = `${(obj.hp / 100) * 100}%`;
        mpBar.style.width = `${((obj.mp || 50) / 50) * 100}%`;
      }

      if (selectedObjectIndex !== null) {
        const player = objects[selectedObjectIndex];
        const atk = player.weapon ? player.weapon.attack : 5;
        let nearestMob = null;
        let nearestDist = 80;
        for (const mob of objects) {
          if (mob !== player && mob.type === "mob") {
            const dx = (player.x + player.width / 2) - (mob.x + mob.width / 2);
            const dy = (player.y + player.height / 2) - (mob.y + mob.height / 2);
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < nearestDist) {
              nearestDist = dist;
              nearestMob = mob;
            }
          }
        }
        const hud = document.getElementById("mobHUD");
        if (nearestMob) {
          const hp = Math.max(0, nearestMob.hp || 100);
          document.getElementById("mobName").textContent = `Mob: ${nearestMob.name}${nearestMob.variant === 4 ? ' (Boss)' : ''}`;
          document.getElementById("mobHPText").textContent = `HP: ${hp}`;
          document.getElementById("mobHpBar").style.width = `${(hp / 100) * 100}%`;
          document.getElementById("mobStatus").textContent = nearestMob.hp <= 30 ? 'Weak' : '';
          hud.style.display = 'block';
        } else {
          hud.style.display = 'none';
        }
      }
      requestAnimationFrame(draw);
    }

    draw();
  </script>
  <footer style="position: absolute; bottom: 5px; left: 10px; font-size: 12px; color: #777;">
    Â© Edwin Jonathan Gustavsson
  </footer>
</body>
</html>
